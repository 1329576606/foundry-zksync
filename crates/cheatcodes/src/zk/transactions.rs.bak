use core::marker::PhantomData;
use ethers_core::abi::ethabi::{self, ParamType};
use itertools::Itertools;
use multivm::{
    interface::dyn_tracers::vm_1_4_1::DynTracer,
    vm_latest::{HistoryDisabled, HistoryMode, SimpleMemory, VmTracer},
};
use revm::{
    primitives::{
        Account, AccountInfo, Address, Bytecode, Bytes, EVMResult, Env, Eval, Halt,
        HashMap as rHashMap, OutOfGasError, ResultAndState, StorageSlot, TxEnv, B256, KECCAK_EMPTY,
        U256 as rU256,
    },
    Database,
};
use std::{
    collections::{HashMap, HashSet},
    fmt::Debug,
    sync::{Arc, Mutex},
};
use zksync_basic_types::{web3::signing::keccak256, L2ChainId, H160, H256, U256};
use zksync_state::WriteStorage;
use zksync_types::{
    fee::Fee, l2::L2Tx, transaction_request::PaymasterParams, Nonce, PackedEthSignature,
    StorageKey, StorageValue, ACCOUNT_CODE_STORAGE_ADDRESS, CONTRACT_DEPLOYER_ADDRESS,
    KNOWN_CODES_STORAGE_ADDRESS,
};
use zksync_utils::{
    be_words_to_bytes, bytecode::hash_bytecode, h256_to_account_address, h256_to_u256, u256_to_h256,
};

use foundry_common::{
    conversion_utils::address_to_h160,
    fix_l2_gas_limit, fix_l2_gas_price,
    zk_utils::{
        conversion_utils::{h160_to_address, h256_to_h160, h256_to_revm_u256, revm_u256_to_u256},
        factory_deps::PackedEraBytecode,
    },
    AsTracerPointer, StorageModificationRecorder, StorageModifications,
};

use foundry_evm_core::backend::DatabaseExt;

use super::{db::ZKVMData, vm::run_l2_tx_raw, storage_view::StorageView};

/// Prepares calldata to invoke deployer contract.
/// This method encodes parameters for the `create` method.
pub fn encode_deploy_params_create(
    salt: H256,
    contract_hash: H256,
    constructor_input: Vec<u8>,
) -> Vec<u8> {
    // TODO (SMA-1608): We should not re-implement the ABI parts in different places, instead have
    // the ABI available  from the `zksync_contracts` crate.
    let signature = ethabi::short_signature(
        "create",
        &[
            ethabi::ParamType::FixedBytes(32),
            ethabi::ParamType::FixedBytes(32),
            ethabi::ParamType::Bytes,
        ],
    );
    let params = ethabi::encode(&[
        ethabi::Token::FixedBytes(salt.as_bytes().to_vec()),
        ethabi::Token::FixedBytes(contract_hash.as_bytes().to_vec()),
        ethabi::Token::Bytes(constructor_input),
    ]);

    signature.iter().copied().chain(params).collect()
}

/// Extract the zkSync Fee based off the Revm transaction.
pub fn tx_env_to_fee(tx_env: &TxEnv) -> Fee {
    Fee {
        gas_limit: fix_l2_gas_limit(tx_env.gas_limit.into()),
        max_fee_per_gas: fix_l2_gas_price(revm_u256_to_u256(tx_env.gas_price)),
        max_priority_fee_per_gas: revm_u256_to_u256(tx_env.gas_priority_fee.unwrap_or_default()),
        gas_per_pubdata_limit: U256::from(800),
    }
}

// pub fn get_nonce<'a, DB>(address: Address, db: &'a mut DB) -> u64
// where
//     DB: Database,
//     <DB as revm::Database>::Error: Debug,
// {
//     let mut era_db = RevmDatabaseForEra::new(db, 0);
//     era_db.get_tx_nonce(address_to_h160(address))
// }

pub fn run_era_transaction<'a, DB, E>(
    mut tx: L2Tx,
    env: &'a mut Env,
    db: &'a mut DB,
) -> EVMResult<E>
where
    DB: Database,
    <DB as revm::Database>::Error: Debug,
{
    let mut era_db = ZKVMData::new_with_system_contracts(db);
    let is_create = tx.execute.contract_address == zksync_types::CONTRACT_DEPLOYER_ADDRESS;
    println!(">> ERA TX caller={:?}", env.tx.caller);

    let env = env.clone();
    // Update the environment timestamp and block number.
    // Check if this should be done at the end?
    // In general, we do not rely on env as it's consistently maintained in foundry
    // env.block.number = env.block.number.saturating_add(rU256::from(1));
    // env.block.timestamp = env.block.timestamp.saturating_add(rU256::from(1));

    let chain_id_u32 =
        if env.cfg.chain_id <= u32::MAX as u64 { env.cfg.chain_id as u32 } else { 31337 };

    if tx.common_data.signature.is_empty() {
        // FIXME: This is a hack to make sure that the signature is not empty.
        // Fails without a signature here: https://github.com/matter-labs/zksync-era/blob/73a1e8ff564025d06e02c2689da238ae47bb10c3/core/lib/types/src/transaction_request.rs#L381
        tx.common_data.signature = PackedEthSignature::default().serialize_packed().into();
    }

    let modified_storage_keys = era_db.override_keys.clone();
    let storage_ptr = StorageView::new(&mut era_db, modified_storage_keys).into_rc_ptr();
    let (tx_result, bytecodes, modified_storage) = run_l2_tx_raw(
        tx,
        storage_ptr.clone(),
        L2ChainId::from(chain_id_u32),
        u64::max(env.block.basefee.to::<u64>(), 1000),
        vec![],
    );

    let execution_result = match tx_result.result {
        multivm::interface::ExecutionResult::Success { output, .. } => {
            println!("ZK-RESULT {}", hex::encode(&output));
            let logs = tx_result
                .logs
                .events
                .clone()
                .into_iter()
                .map(|event| revm::primitives::Log {
                    address: h160_to_address(event.address),
                    topics: event.indexed_topics.iter().cloned().map(|t| B256::from(t.0)).collect(),
                    data: event.value.into(),
                })
                .collect_vec();
            let result = decode_l2_tx_result(output);
            let address = if result.len() == 32 {
                Some(h256_to_account_address(&H256::from_slice(&result)))
            } else {
                None
            };
            let output = if is_create {
                revm::primitives::Output::Create(Bytes::from(result), address.map(h160_to_address))
            } else {
                revm::primitives::Output::Call(Bytes::from(result))
            };

            revm::primitives::ExecutionResult::Success {
                reason: Eval::Return,
                gas_used: tx_result.statistics.gas_used as u64,
                gas_refunded: tx_result.refunds.gas_refunded as u64,
                logs,
                output,
            }
        }
        multivm::interface::ExecutionResult::Revert { output } => {
            let output = match output {
                multivm::interface::VmRevertReason::General { data, .. } => data,
                multivm::interface::VmRevertReason::Unknown { data, .. } => data,
                _ => Vec::new(),
            };

            revm::primitives::ExecutionResult::Revert {
                gas_used: env.tx.gas_limit - tx_result.refunds.gas_refunded as u64,
                output: Bytes::from(output),
            }
        }
        multivm::interface::ExecutionResult::Halt { reason } => {
            // Need to decide what to do in the case of a halt. This might depend on the reason for
            // the halt. TODO: FIXME
            tracing::error!("tx execution halted: {}", reason);
            revm::primitives::ExecutionResult::Halt {
                reason: match reason {
                    multivm::interface::Halt::NotEnoughGasProvided => {
                        Halt::OutOfGas(OutOfGasError::BasicOutOfGas)
                    }
                    _ => panic!("HALT: {}", reason),
                },
                gas_used: env.tx.gas_limit - tx_result.refunds.gas_refunded as u64,
            }
        }
    };

    let mut state: rHashMap<Address, Account> = Default::default();
    let mut storage: rHashMap<Address, rHashMap<rU256, StorageSlot>> = Default::default();
    let mut codes: rHashMap<Address, (B256, Bytecode)> = Default::default();
    for (k, v) in &modified_storage {
        let address = h160_to_address(*k.address());
        let index = h256_to_revm_u256(*k.key());
        let previous = era_db.db.storage(address, index).unwrap_or_default();
        let entry = storage.entry(address).or_default();
        entry.insert(index, StorageSlot::new_changed(previous, h256_to_revm_u256(*v)));

        if k.address() == &ACCOUNT_CODE_STORAGE_ADDRESS {
            if let Some(bytecode) = bytecodes.get(&h256_to_u256(*v)) {
                let bytecode =
                    bytecode.iter().flat_map(|x| u256_to_h256(*x).to_fixed_bytes()).collect_vec();
                let bytecode = Bytecode::new_raw(Bytes::from(bytecode));
                let hash = B256::from_slice(v.as_bytes());
                codes.insert(h160_to_address(h256_to_h160(k.key())), (hash, bytecode));
            }
        }
    }

    for (address, storage) in storage {
        println!("{:?} {:#?}", address, storage);
        let (info, status) = match era_db.db.basic(address).ok().flatten() {
            Some(info) => (info, revm::primitives::AccountStatus::Touched),
            None => (AccountInfo::default(), revm::primitives::AccountStatus::Created),
        };
        let account = Account {
            info: AccountInfo {
                balance: info.balance,
                nonce: info.nonce,
                code_hash: KECCAK_EMPTY,
                code: None,
            },
            storage,
            status,
        };
        state.insert(address, account);
    }

    for (address, (code_hash, code)) in codes {
        println!("{:?} {:?}", address, code_hash);
        let (info, status) = match era_db.db.basic(address).ok().flatten() {
            Some(info) => (info, revm::primitives::AccountStatus::Touched),
            None => (AccountInfo::default(), revm::primitives::AccountStatus::Created),
        };
        let account = Account {
            info: AccountInfo {
                balance: info.balance,
                nonce: info.nonce,
                code_hash,
                code: Some(code),
            },
            storage: Default::default(),
            status,
        };
        state.insert(address, account);
    }

    Ok(ResultAndState {
        result: execution_result,
        state,
        // state: storage_to_state(&mut era_db, &modified_storage, bytecodes),
    })
}

fn decode_l2_tx_result(output: Vec<u8>) -> Vec<u8> {
    ethabi::decode(&[ParamType::Bytes], &output)
        .ok()
        .and_then(|result| result.first().cloned())
        .and_then(|result| result.into_bytes())
        .unwrap_or_default()
}
